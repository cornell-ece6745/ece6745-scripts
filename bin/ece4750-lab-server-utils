#!/usr/bin/env python
#=========================================================================
# ece4750-lab-server-utils [options]
#=========================================================================
#
#  -h --help        Display this message
#

# Author : Khalid Al-Hawaj
# Date   : August 26, 2017
#
# This is a utils server that authenticate the username through open ports

import argparse
import os
import sys
import threading
import socket
import subprocess
import time
import signal
import datetime

from server_config import server_config
from global_config import global_config

gConfigs = global_config()
sConfigs = server_config()

sys.path.append("/classes/ece4750/install/venv-pkgs/x86_64-rhel7/python2.7.12/lib/python2.7/site-packages/PyGithub-1.27.1-py2.7.egg")

#-------------------------------------------------------------------------
# Global variables
#-------------------------------------------------------------------------

server_shutdown = False

#-------------------------------------------------------------------------
# Force flush for stdout
#-------------------------------------------------------------------------
# https://stackoverflow.com/questions/107705

class Unbuffered(object):
   def __init__(self, stream):
       self.stream = stream
   def write(self, data):
       self.stream.write(data)
       self.stream.flush()
   def writelines(self, datas):
       self.stream.writelines(datas)
       self.stream.flush()
   def __getattr__(self, attr):
       return getattr(self.stream, attr)

sys.stdout = Unbuffered(sys.stdout)

#-------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------

class Logger(object):

  INFO = 0
  WARN = 1
  ERR  = 2

  def __init__( s, printOutput=True, outputFile=None ):
    s.printOutput = True
    s.outputFile  = open( outputFile, 'a' ) if outputFile else None
    s.startTime   = time.time()

  def __print__ ( s, level, msg ):
    ts     = time.time() - s.startTime
    ts_str = '{:20.3f}'.format( ts )
    t      = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    level_name = ''

    if level == s.INFO:
      level_name = 'INFO   :'
    if level == s.WARN:
      level_name = 'WARNIMG:'
    if level == s.ERR :
      level_name = 'ERROR  :'

    output_str = '[{}][{}] {} {}'.format( ts_str, t, level_name, msg )

    if s.printOutput:
      print(output_str)

    if s.outputFile:
      s.outputFile.write( output_str )

  def warning ( s, msg ):
    s.__print__( s.WARN, msg )

  def error   ( s, msg ):
    s.__print__( s.ERR , msg )

  def info    ( s, msg ):
    s.__print__( s.INFO, msg )

logger = Logger()

#-------------------------------------------------------------------------
# Handle termination signal
#-------------------------------------------------------------------------

def sigint_handler (signal_num, frame):
  global server_shutdown
  global logger

  print('')

  logger.warning( 'Recieved signal ({}) ...'.format( signal_num ) )
  logger.info( 'Server shutting down gracefully' )

  server_shutdown = True
 
signal.signal(signal.SIGINT , sigint_handler)
signal.signal(signal.SIGTERM, sigint_handler)

#-------------------------------------------------------------------------
# Command Line Processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = '' ):
    if ( msg ): print('\n ERROR: %s' % msg)
    print('')
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != '')
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip('\n') )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  p.add_argument( '-h', '--help', action='store_true'         )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

opts = parse_cmdline()

#-------------------------------------------------------------------------
# Connection utilities
#-------------------------------------------------------------------------

def send_data ( sock, data, drastic = True ):

  # Assume data is ASCII
  length = len( data )
  new_data = '{:04d}{}'.format( length, data )

  # Send the packet
  try:
    sock.sendall( new_data )
  except:
    print('ERROR: cannot send data')
    if drastic:
      sock.close()
      quit ( -1 )
    else:
      pass

def recv_data ( sock, drastic = False ):

  # Again, data is text :)
  data = None

  try:
    # Get packet length
    tmp = sock.recv( 4 )
    length = int( tmp )
    data = sock.recv( length )
  except:
    if drastic:
      sock.close()
      quit ( -1 )
    else:
      pass

  return data

#-------------------------------------------------------------------------
# Subshell stuff
#-------------------------------------------------------------------------

def subshell( cmd ):

  process        = subprocess.Popen( cmd                    ,
                                     stdin =subprocess.PIPE ,
                                     stdout=subprocess.PIPE ,
                                     shell=True             )
  stdout, stderr = process.communicate()

  del process

  return stdout

#-------------------------------------------------------------------------
# Main servicing logic
#-------------------------------------------------------------------------

def service_request( client, conn_point ):

  # Globals
  global logger

  # Retrieve actual arguments
  addr = conn_point[0]
  port = conn_point[1]

  # Read the request string
  data = recv_data( client )

  # Do we even have a request :) ?
  if data == 'Knock! Knock!':

    # Authenticate
    send_data( client, 'Yes? This is Blink-182!' )

    # Wait for a confirmation
    data = recv_data( client )

    if data:
      req   = data.split( '\n' )
      # Make this pretty :)
      query = "netstat -nte 2>/dev/null | sed 's/^\\S\\+\\s\\+\\S\\+\\s\\+\\S\\+\\s\\+\\(\\S\\+\\):\\([^: \\t]\\+\\)\\s\\+\\(\\S\\+\\):\\([^: \\t]\\+\\)\\s\\+\\(\\S\\+\\)\\s\\+\\(\\S\\+\\)\\s\\+\\(\\S\\+\\)\\s\\+.*/\\1,\\2 -- \\3,\\4 -- \\5 -- \\6:\\7/'"
      query += " | grep '.*,{} -- .*,{} -- ESTABLISHED'".format( req[0], req[1] )
      query += " | sed 's/^\S\+,\S\+\s\+--\s\+\S\+,\S\+\s\+--\s\+\S\+\s\+--\s\+\(\S\+\):\S\+$/\\1/'"
      uid      = subshell( query ).rstrip('\n')

      username = ''
      if uid.rstrip():
        query    = 'id -nu {}'.format(uid)
        username = subshell( query ).rstrip('\n')

      send_data( client, username )

      if username:
        logger.info( 'Authorized user "{}" (uid={})'.format( username, uid ) )
      else:
        logger.warning( 'Could not authorize a user' )

  # Close connection
  client.close()

#-------------------------------------------------------------------------
# Main execution logic
#-------------------------------------------------------------------------

# Announce the start of the utility server
logger.info( 'Starting the utility server ...' )

#-------------------------------------------------------------------------
# Create a socket
#-------------------------------------------------------------------------
sock = socket.socket( socket.AF_INET, socket.SOCK_STREAM )
sock.setsockopt( socket.SOL_SOCKET, socket.SO_REUSEADDR, 1 )

address = ( '', sConfigs.utils_port )

logger.info( 'Attempting to listen to incoming connections on port {}'.format( sConfigs.utils_port ) )

try:
  sock.bind(address)
  sock.listen(5)

except:
  print('ERROR: Cannot bind/listen to assigned port')
  quit( -1 )

#-------------------------------------------------------------------------
# Main dispatch loop
#-------------------------------------------------------------------------

# Time-out
sock.settimeout(1)

while not server_shutdown:

  try:
    client, address = sock.accept()
    client.settimeout(60)
    threading.Thread(target = service_request, args = (client, address)).start()

  except:
    pass
