#!/usr/bin/env python
#=========================================================================
# ece4750-lab-server [options]
#=========================================================================
#
#  -v --verbose                  Turn on verbose mode
#  -h --help                     Display this message
#

# Author : Khalid Al-Hawaj
# Date   : August 25, 2017

# Argument parser
import argparse

# System stuff
import sys
import os
import datetime
import signal
import time
import subprocess
import requests

# Database backend
import json
import csv

# Socket and threading!
import socket
import threading

# Random
from random import *

# Math stuff
from math import ceil

# Import stuff from previous implementations
import smtplib
import binascii
import logging

# Configuration
from server_config import server_config
from global_config import global_config

# GitHub stuff
from github import Github
from github import GithubException

#-------------------------------------------------------------------------
# Constants
#-------------------------------------------------------------------------

gConfigs = global_config()
sConfigs = server_config()

superusers = sConfigs.getSU()
admins     = superusers

#-------------------------------------------------------------------------
# Force flush for stdout
#-------------------------------------------------------------------------
# https://stackoverflow.com/questions/107705

class Unbuffered(object):
  def __init__(self, stream):
    self.stream = stream
  def write(self, data):
    self.stream.write(data)
    self.stream.flush()
  def writelines(self, datas):
    self.stream.writelines(datas)
    self.stream.flush()
  def __getattr__(self, attr):
    return getattr(self.stream, attr)

sys.stdout = Unbuffered(sys.stdout)

#-------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------

class Logger(object):

  INFO = 0
  WARN = 1
  ERR  = 2

  def __init__( s, printOutput=True, outputFile=None ):
    s.printOutput = True
    s.outputFile  = open( outputFile, 'a' ) if outputFile else None
    s.startTime   = time.time()

  def __print__ ( s, level, msg ):
    ts     = round( time.time() - s.startTime , 3 )
    ts_str = '{:12.3f}'.format( ts )
    t      = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    level_name = ''

    if level == s.INFO:
      level_name = 'INFO   :'
    if level == s.WARN:
      level_name = 'WARNING:'
    if level == s.ERR :
      level_name = 'ERROR  :'

    output_str = '[{}][{}] {} {}'.format( ts_str, t, level_name, msg )

    if s.printOutput:
      print(output_str)

    if s.outputFile:
      s.outputFile.write( output_str )

  def warning ( s, msg ):
    s.__print__( s.WARN, msg )

  def error   ( s, msg ):
    s.__print__( s.ERR , msg )

  def info    ( s, msg ):
    s.__print__( s.INFO, msg )

logger = Logger()

#-------------------------------------------------------------------------
# Command Line Processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = '' ):
    if ( msg ): print('\n ERROR: %s' % msg)
    print('')
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != '')
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip('\n') )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  p.add_argument( '-v', '--verbose',             action='store_true'         )
  p.add_argument( '-h', '--help',                action='store_true'         )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

opts = parse_cmdline()

#-------------------------------------------------------------------------
# Subshell stuff
#-------------------------------------------------------------------------

def subshell( cmd ):

  process        = subprocess.Popen( cmd                    ,
                                     stdin =subprocess.PIPE ,
                                     stdout=subprocess.PIPE ,
                                     stderr=subprocess.PIPE ,
                                     shell=True             )
  stdout, stderr = process.communicate()

  del process

  return stdout

#-------------------------------------------------------------------------
# Paths
#-------------------------------------------------------------------------

# hawajkm: Let's do relative path
sep                   = os.path.sep
executable_path       = os.path.dirname(os.path.realpath(__file__))
base_path             = os.path.realpath(executable_path + sep + '..' + sep + '..') + sep
base_path             = '/classes/ece4750/staff/'

database_path         = base_path     + 'database/'
assignments_path      = database_path + 'assignments/'

class_roster_file     = database_path + 'class_roster.csv'

student_info_file     = database_path + 'student-info.json'
student_csv_file      = database_path + 'student-info.csv'

group_info_file       = database_path + 'group-info.json'
group_csv_file        = database_path + 'group-info.csv'

assignments_info_file = database_path + 'assignments.json'

executable_path       = os.path.dirname(os.path.realpath(__file__))


# Internal databases/structures
student_info     = {}
group_info       = {}
assignments_info = {}

#-------------------------------------------------------------------------
# Functions to update/load databases
#-------------------------------------------------------------------------

def load_student_info():

  global student_info
  global init_db_dirty
  
  student_info = {}
  if os.path.exists( student_info_file ):
    with open( student_info_file, 'r' ) as fp:
      student_info = json.load( fp )
  else:
    init_db_dirty = init_db_dirty | True

def load_group_info():

  global group_info
  global init_db_dirty

  group_info = {}
  if os.path.exists( group_info_file ):
    with open( group_info_file, 'r' ) as fp:
      group_info = json.load( fp )
  else:
    init_db_dirty = init_db_dirty | True

def load_assignments_info():

  global assignments_info

  assignments_metadata = {}
  if os.path.exists( assignments_info_file ):
    with open( assignments_info_file, 'r' ) as fp:
      assignments_metadata = json.load( fp )
  
  assignments_info = {}
  for a_id in assignments_metadata:
  
    name          = assignments_metadata[a_id]['name']
    slipdays_file = assignments_path + assignments_metadata[a_id]['slipdays']
  
    # Load slipdays in a dictionary
    if not os.path.exists( slipdays_file ):
      continue
  
    assignments_info[a_id]             = {}
    assignments_info[a_id]['name']     = name
    assignments_info[a_id]['slipdays'] = {}
  
    slipdays_dict = {}
  
    # Load slipdays as a database
    with open( slipdays_file, 'r' ) as fp:
      slipdays_csv = csv.reader( fp )
  
      for slipdays_entry in slipdays_csv:
        net_id       = slipdays_entry[0]
        num_slipdays = slipdays_entry[1]
        assignments_info[a_id]['slipdays'][net_id] = int( num_slipdays )

# Shunning email spamming bot :)

#logging.basicConfig(  filename=database_path+"ece4750-bot-mail.log",
#                      format='%(asctime)s %(message)s',
#                      datefmt='%m/%d/%Y %I:%M:%S %p',
#                      level = logging.INFO
#                      )
#user = "ece4750.bot"
#botpwd = None
#
#with open( base_path + "scripts/ece4750-bot-password","r") as f:
#  botpwd = (f.read())[:-1]
#
#server = None
#try:
#  server = smtplib.SMTP( "smtp.gmail.com", 587 )
#  server.ehlo()
#  server.starttls()
#  server.login( user, botpwd )
#  logging.info("  Successfully login gmail" )
#except:
#  logging.warning( "  Failed to log in to gmail" )
#  pass

# Database/lists loading

init_db_dirty = False

# Load students database
load_student_info()

# Load groups information
load_group_info()

# Load assignements Information
load_assignments_info()

#-------------------------------------------------------------------------
# Utils
#-------------------------------------------------------------------------

def find_empty_group( status ):
  global group_info

  if status == 'g':
    for gid in [ str(x) for x in xrange(1, 41) ]:
      if (not gid in group_info.keys()) or (len(group_info[gid]['members']) == 0):
        return gid

  if status == 'a':
    for gid in [ 'a{}'.format(x) for x in xrange(1, 41) ]:
      if (not gid in group_info.keys()) or (len(group_info[gid]['members']) == 0):
        return gid

  return None

def write_student_info():
  # write student-info.json
  with open( student_info_file, 'w' ) as fp:
    json.dump( student_info, fp, indent=4 )

  # write student-info.csv
  with open( student_csv_file, 'wt+' ) as fp:
    csvw = csv.writer( fp )

    csvw.writerow( ['netid', 'name', 'github_id', 'group', 'slipdays'] )

    for stu, stu_entry in student_info.items():
      csvw.writerow([ stu,
                      stu_entry['name'],
                      stu_entry['github_id'],
                      stu_entry['group'][1] if stu_entry['group'] else None,
                      stu_entry['slipdays']
                    ])

def update_group_info():
  global group_info

  # Remove all members information
  for gid in group_info.keys():
    group_info[gid]['members'] = []

  # Add active students back in
  for netid in student_info.keys():
    gid = student_info[netid]['group']

    if gid:
      if gid[0] == 'c':
        group_id = gid[1]
        if group_id in group_info.keys():
          group_info[group_id]['members'].append( netid )
        else:
          group_info[group_id] = { 'members'      : [ netid ],
                                   'pending_reqs' : [       ] }

  # Remove empty groups
  for gid in group_info.keys():
    if len(group_info[gid]['members']) == 0:
      del group_info[gid]

def write_group_info():
  # write group-info.json
  global group_info
  with open( group_info_file, 'w' ) as fp:
    json.dump( group_info, fp, indent=4 )

  # write group-info.csv
  with open( group_csv_file, 'wt+' ) as fp:
    csvw = csv.writer( fp )

    csvw.writerow( ['Group Number', 'Member 1', 'Member 2', 'Member 3', 'Member 4'] )

    for gid in group_info.keys():
      csvw.writerow( [gid] + group_info[gid]['members'] )

def send_email( netid, name, title, kind, success=True):
  global server
  
  From    = "ece4750.bot@gmail.com"
  To      = [netid+"@cornell.edu"]
  Cc      = ["sj634@cornell.edu"]
  subject = "[ECE 4750] %s" % title
  
  text = "is processed"
  if success:
    text = "has been successfully processed. It may take a while before the change takes an effect"

  text    = '''
Dear {},

Greetings! 
  
You recently submitted {} request {}.

Yours Truly,
ECE4750-bot
'''.format( name, kind, text )

  message = "From: %s\r\n" % From \
          + "To: %s\r\n" % ",".join(To) \
          + "CC: %s\r\n" % ",".join(Cc) \
          + "Subject: %s\r\n" % subject \
          + "\r\n" \
          + text
  
  try:
    server.sendmail( From, To + Cc, message )
  except:
    logging.warning( "  Failed to send notification to %s" % To[0] )

#-------------------------------------------------------------------------
# Connection utilities
#-------------------------------------------------------------------------

def send_data ( sock, data, drastic = True ):

  # Assume data is ASCII
  length = len( data )
  new_data = '{:04d}{}'.format( length, data )

  # Send the packet
  try:
    sock.sendall( new_data )
  except:
    print('ERROR: cannot send data')
    if drastic:
      sock.close()
      quit ( -1 )
    else:
      pass

def recv_data ( sock, drastic = False ):

  # Again, data is text :)
  data = None

  try:
    # Get packet length
    tmp = sock.recv( 4 )
    length = int( tmp )
    data = sock.recv( length )
  except:
    if drastic:
      sock.close()
      quit ( -1 )
    else:
      pass

  return data

#-------------------------------------------------------------------------
# Locks, counters, and status variables
#-------------------------------------------------------------------------

num_updaters = 0

group_lock   = threading.Lock()
counter_lock = threading.Lock()

db_dirty        = init_db_dirty
server_shutdown = False
stall_requests  = False
reset_db        = False
update_db       = False
refresh_db      = False
force_update    = False
server_started  = False

sync_db         = threading.Event()

github_obj   = None
github_token = None
course_org   = None
generic_team = None
groups_teams = None

#-------------------------------------------------------------------------
# Locking mechanism
#-------------------------------------------------------------------------

def admit_updater():

  # Global stuff
  global counter_lock
  global num_updaters

  # Acquire the lock
  counter_lock.acquire()

  # Increase number of updaters
  num_updaters += 1

  # Release the lock
  counter_lock.release()

def release_updater():

  # Global stuff
  global counter_lock
  global num_updaters

  # Acquire the lock
  counter_lock.acquire()

  # Increase number of updaters
  num_updaters -= 1

  # Release the lock
  counter_lock.release()

def wait_for_updaters( expected = 0 ):

  # Global stuff
  global num_updaters

  while (num_updaters != expected) :
    pass

#-------------------------------------------------------------------------
# Service utilities
#-------------------------------------------------------------------------

#=========================================
# Authenticate NetID's
#=========================================
def retrieve_netid( addr, port ):

  # To be ...
  netid = None

  # Connect to a service in the same server it is coming from
  sock = None

  try:
    sock = socket.create_connection(( addr, sConfigs.utils_port ))
  except:
    return None

  if sock:

    # Authenticate
    send_data( sock, 'Knock! Knock!' )
    data = recv_data( sock )

    if data and data == 'Yes? This is Blink-182!':

      # Send the request
      send_data( sock, '{}\n{}'.format( port, gConfigs.server_port ) )
      data = recv_data( sock )

      if data:
        netid = data

  # Finished
  return netid

#=========================================
# Refresh the Database from students' list
#=========================================
def refresh_database ( force = False ):

  # Globals
  global student_info

  # Log!
  log = ''

  if os.path.exists( class_roster_file ):

    # Dictionary for students
    class_roster = {}

    # Load all students
    with open( class_roster_file, 'r' ) as fp:

      db_raw = csv.DictReader( fp )

      for row in db_raw:
        netid = row['NET ID']
        name  = row['NAME'].split(',')
        name  = [ x.strip() for x in name ]
        name  = ' '.join(list(reversed( name )))

        class_roster[netid] = row
        class_roster[netid]['NAME'] = name

    # Add new students
    for netid in sorted( class_roster.keys() ):

      name   = class_roster[netid]['NAME']
      status = class_roster[netid]['GRADING BASIS']

      if   status == 'GRV':
        status = 'g'
      elif status == 'AUD':
        status = 'a'
      else:
        status = 'u'

      # Add!
      if not (netid in student_info.keys()):

        log += '\n' if log != '' else ''
        log += 'Adding {}'.format( netid )

        student_info[netid] = {}

        #student_info[netid]['name'     ] = name
        #student_info[netid]['group'    ] = None
        #student_info[netid]['github_id'] = None
        #student_info[netid]['slipdays' ] = 3
        #student_info[netid]['status'   ] = status

      # Check if updated!

      if not ('name' in student_info[netid] and student_info[netid]['name'] == name):
        old_name = student_info[netid]['name'] if ('name' in student_info[netid]) else ''

        student_info[netid]['name'] = name

        log += '\n' if log != '' else ''
        log += 'Updating {}\'s name from "{}" to "{}"'.format( netid, old_name, name )

      if not ('status' in student_info[netid] and student_info[netid]['status'] == status):
        old_status = student_info[netid]['status'] if ('status' in student_info[netid]) else ''

        student_info[netid]['status'] = status

        log += '\n' if log != '' else ''
        log += 'Updating {}\'s status from "{}" to "{}"'.format( netid, old_status, status )

      if not 'group' in student_info[netid]:

        student_info[netid]['group'] = None

        log += '\n' if log != '' else ''
        log += 'Initializing {}\'s group to None'.format( netid )

      if not 'slipdays' in student_info[netid]:

        student_info[netid]['slipdays'] = 3

        log += '\n' if log != '' else ''
        log += 'Initializing {}\'s slipdays to 3'.format( netid )

      if not 'github_id' in student_info[netid]:

        student_info[netid]['github_id'] = None

        log += '\n' if log != '' else ''
        log += 'Initializing {}\'s GitHub ID to None'.format( netid )

    # Experimental ... :)
    # Delete departing students ...
    for netid in student_info.keys():

      if not netid in class_roster.keys():
        # Students dropped the course
        name = student_info[netid]['name']
        github_user = student_info[netid]['github_id']

        if force or not github_user:
          if github_user:
            # Remove from the group
            leave_group( netid )

            # Remove from organization
            try:
              course_org.remover_from_members( github_id )
            except:
              # Probably add to blacklist?
              pass

          # Delete student's record
          del student_info[netid]

          # Logging
          log += '\n' if log != '' else ''
          if github_user:
            log += 'Removing {} (name={}, github_id={})'.format( netid, name, github_user )
          else:
            log += 'Removing {} (name={})'.format( netid, name )

        # Force was not set!
        elif github_user:
          log += '\n' if log != '' else ''
          log += 'Can not softly remove {} (name={}, github_id={})'.format( netid, name, github_user )

  # :)
  return log

#-------------------------------------------------------------------------
# Thread for writing the database
#-------------------------------------------------------------------------

def sync_database ():

  # Globals
  global server_started
  global server_shutdown
  global student_info
  global group_info
  global assignments_info
  global db_dirty
  global stall_requests
  global update_db
  global force_update
  global reset_db
  global sync_db
  global logger

  # Infinit loop
  while True:

    sync_db.wait(5)

    # Reset event just in case
    sync_db.clear()

    # Process refresh requests
    if refresh_db:

      load_assignments_info()

    # Check if db_dirty
    if db_dirty or server_shutdown:

      # Hmmm ...
      log = ''

      # Stop incoming requests
      stall_requests = True

      # Wait for requests in-flight
      wait_for_updaters()

      # Check pending requests
      if   reset_db:
        student_info = {}
        group_info   = {}

        reset_db  = False
        update_db = False

        logger.info( 'Database has been resetted!' )

      elif update_db:
        # This is far too complex to fit here
        if server_started:
          log = refresh_database ( force_update )
          update_db = False
          force_update = False

          logger.info( 'Database has been updated' )

      # Update group database
      update_group_info()

      # Update the database on the disk
      write_student_info()
      write_group_info()

      # Print log
      logger.info( 'Database has been synchronized' )
      if log != '':
        logger.warning( 'Database synchronization log:' )

        for line in log.split('\n'):
          logger.warning( '  {}'.format( line ) )

      # Reset dirty bit
      db_dirty = False

      # Resume incoming requests
      stall_requests = False

      # If we are doing a shutdown
      if server_shutdown:
        return

#-------------------------------------------------------------------------
# Helper functions
#-------------------------------------------------------------------------

#=========================================
# Boyer-Moore Algorithm
#=========================================
def get_majority_vote ( array ):

  # State
  count = 0
  vote  = 0

  # Iterate
  for e in array:

    if count == 0:
      # We have a new candidate
      vote = e
      count += 1

    else:

      # Voting
      if e == vote:
        count += 1
      else:
        count -= 1

  return ( (count > 0), vote )

#=========================================
# Median
#=========================================
def median ( array ):

  sz = len( array )

  if sz <= 0:
    return 0

  array = sorted( array )

  if sz % 2 == 0:
    n1 = array[sz//2-1]
    n2 = array[sz//2+0]
    return int( ceil( ( n1 + n2 ) / 2.0 ) )
  else:
    return array[sz//2]

#=========================================
# Get students remaining slipdays
#=========================================
def get_student_slipdays ( netid ):

  # Globals
  global student_info
  global assignments_info
  global superusers
  global server_started
  global server_shutdown

  slipdays = student_info[netid]['slipdays']
  if isinstance( slipdays, basestring ):
    if slipdays.isdigit():
      slipdays = int( slipdays )
    else:
      slipdays = 0

  used_slipdays = 0

  len_hdr = len( 'Assignment' )
  header  = 'Assignment\tUsed slipdays'.expandtabs(10)

  msg  = '\n'
  msg += '\n' + header
  msg += '\n' + ( '-' * len(header) )

  # Slipdays
  for a_id in assignments_info:
    name    = assignments_info[a_id]['name'    ]
    name    = name + ( ' ' * ( len_hdr - len( name ) ) )
    
    sd_list = assignments_info[a_id]['slipdays']
    #slipdays = None
    sd = 0
    if netid in sd_list:
      sd = sd_list[netid]

    #if slipdays == None:
    #  msg += '{}\t{}'
    used_slipdays += sd

    msg += '\n{}\t{}'.format( name, sd ).expandtabs(10)

  slipdays -= used_slipdays

  msg += '\n' + ( '-' * len(header) )
  tmp    = 'Total'
  tmp    = tmp + ( ' ' * ( len_hdr - len(tmp) ) )
  msg += '\n{}\t{}'.format( tmp, used_slipdays ).expandtabs(10)

  return ( msg, slipdays )

#=========================================
# Get students status
#=========================================
def get_student_status ( netid, github_id, group ):

  # Globals
  global student_info
  global group_info
  global assignments_info
  global superusers
  global server_started
  global server_shutdown

  ret = 0
  msg = 'Your NetID is {}'.format(netid)
  if github_id:
    msg += '\nYour GitHub ID is set to "{}"'.format(github_id)
  else:
    msg += '\nYour GitHub ID has NOT been set.'
  if group:
    if   group[0] == 'c':
      msg += '\nYou are assigned to group {}'.format(group[1])
    elif group[0] == 'p':
      msg += '\nYou have a pending joining request to group {}'.format(group[1])
    else:
      msg += '\nYou have a corrupted group record.'
  else:
    msg += '\nYou are NOT assigned to any group.'

  sd_msg, slipdays = get_student_slipdays( netid )

  # Get slipdays for group
  group_slipdays_lst = []
  if group != None and group[0] == 'c':

    gid = group[1]

    # Enumerate group members
    for member in group_info[gid]['members']:

      tmp, sd = get_student_slipdays( member )
      group_slipdays_lst.append( sd )

  # Slipdays
  msg += '\nRemaining slipdays {}'.format( slipdays )

  # Group's slipdays
  if len(group_slipdays_lst) > 0:

    gid = group[1]

    group_slipdays_med = median( group_slipdays_lst )
    vmaj, group_slipdays_maj = get_majority_vote( group_slipdays_lst )

    if vmaj:
      group_slipdays = max( group_slipdays_med, group_slipdays_maj )
    else:
      group_slipdays = group_slipdays_med

    msg += '\nGroup {} slipdays {}'.format( gid, group_slipdays )

  # Slipdays table
  msg += sd_msg

  return ret, msg

#=========================================
# Update a group's description
#=========================================
def update_group_description ( group_id ):

  # Globals
  global group_lock
  global student_info
  global group_info

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Get GitHub team
  if group_id[0] == 'a':
    group_name = 'audit-group{:02d}'.format( int( group_id[1:] ) )
  else:
    group_name = 'lab-group{:02d}'.format( int( group_id ) )

  repo = course_org.get_repo( group_name )

  # Generate description
  group_members = []
  if group_id in group_info.keys():
    group_members = group_info[group_id]['members']

  names = []
  for netid in group_members:
    names.append( student_info[netid]['name'] + ' (' + netid + ')' )

  description = ', '.join( names )

  repo.edit( group_name, description = description )

#=========================================
# Set database field to a value
#=========================================
# This is highly experimental, but needed
def set_database_field ( netid, field, value ):

  # Globals
  global student_info
  global db_dirty
  global sync_db

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Return
  ret = -1
  msg = ''

  # None for the netid means all students
  skipped_msg = 'Students skipped when value was set:'
  skipped_num = 0
  i           = 1
  if netid == None:
    # Go through all students
    # For now, we don't set the value for students
    # missing the field
    for netid in student_info:

      if field in student_info[netid]:
        student_info[netid][field] = value
      else:
        skipped_msg += '\n' + '{:02} '.format(i) + netid
        skipped_num += 1

  else:
    if field in student_info[netid]:
      student_info[netid][field] = value
    else:
      skipped_msg += '\n' + '{:02} '.format(i) + netid
      skipped_num += 1

  # Construct a message
  ret  = 0
  msg  = "Successfully finished updating the database"
  if skipped_num != 0:
    msg += '\n\n' + skipped_msg

  # Database is dirty
  db_dirty = True

  # Signal update thread
  sync_db.set()

  # Return
  return ( ret, msg )

#=========================================
# Assigning a GitHub to a user
#=========================================
def assign_github_id ( netid, github_id ):

  # Globals
  global student_info
  global db_dirty
  global sync_db

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Return
  ret = -1
  msg = ''

  # If the user is already part of a group
  if student_info[netid]['group'] != None:
    if   student_info[netid]['group'][0] == 'c':
      ret = -100
      msg =   'You are already part of a group.' + \
            '\nLeave the group to be able to change your GitHub ID.'

      return ( ret, msg )

    elif student_info[netid]['group'][0] == 'p':
      ret = -101
      msg =   'You are already have a pending join request for a group.' + \
            '\nDelete the join request to change your GitHub ID.'

      return ( ret, msg )

    else:
      ret = -102
      msg =   'Your group record is corrupted.' + \
            '\nPlease, contact the course\'s staff to fix this.'

      return ( ret, msg )

  # Old github
  o_github_id = student_info[netid]['github_id']

  # This function does NOT catch not included students
  if github_id != '' and (github_id != o_github_id):
    # Old github
    o_github_id = student_info[netid]['github_id']

    # Try to add it to github
    try:
      # Try to add the user to the generic team
      github_user = github_obj.get_user( github_id )
      generic_team.add_membership( github_user )
      try:
        generic_team.add_to_members( github_user )
      except:
        pass

      ret = 0
      msg = 'GitHub ID was successfully updated'
      student_info[netid]['github_id'] = github_id

      if o_github_id != None and o_github_id != 'hawajkm':
        # Worked! Now, remove old github ID. We don't care if this fails
        github_user = github_obj.get_user( o_github_id )
        try:
          generic_team.remove_from_members( github_user )
        except:
          pass

        try:
          course_org.remove_from_members( github_user )
        except:
          pass

        try:
          course_org.remove_from_public_members( github_user )
        except:
          pass

      # Database is dirty
      db_dirty = True

      # Signal update thread
      sync_db.set()

    except:
      ret = 16
      msg =  'Failed to add GitHub ID.' + \
            ' Check whether the ID "{}" is valid.'.format( github_id )

  elif github_id == o_github_id:
    ret = 2
    msg = 'No change to the GitHub ID. This request will be ignored!'

  else:
    ret = 2
    msg = 'Invalid GitHub ID "{}"'.format( github_id )

  # Return
  return ( ret, msg )

#=========================================
# Initialize a README for a repo
#=========================================
def init_repo_readme ( repo, group_num):

  # Globals
  global github_obj
  global github_token
  global sConfigs
  global executable_path

  # Create a token
  # if gh_token is None:
  #   trails = 0
  #   auth = None
  #   while auth == None and trails < 10:
  #     try:
  #       key_name = 'temp_key_{:06d}'.format(randint(0, 999999))
  #       auth = github_obj.get_user().create_authorization(scopes=['repo', 'user'], note='temp_key')
  #       trails = trails +  1
  #     except:
  #       auth = None
  # else:
  #   auth = gh_token

  # Copy the repo
  gh_uname = github_obj.get_user().login
  gh_pwd   = github_token
  org_name = course_org.login
  token    = sConfigs.travis_token

  gh_copy = executable_path + '/ece4750-init-repo'
  cmd     = gh_copy + ' {} {} {} {} {} {}'.format( gh_uname, gh_pwd ,
                                                   org_name, repo   ,
                                                   group_num, token )
  subshell( cmd )

  # Remove authorization token
  # if gh_token is None:
  #   auth.delete()

#=========================================
# Travis CI stuff
#=========================================

def activate_travisCI( org, repo_name):
  global github_token
  # Internally used functions
  def wait_sync( resp ):

    ret = False

    if not resp:
      ret = True
    else:
      resp_code = resp.status_code
      resp      = resp.json()

      if resp_code == 409 and \
         resp['error_type'] == 'already_syncing':
        ret = True

    return ret

  # Get a TravisCI token

  tokenRequest = {
    "github_token": github_token
  }

  # Request for a token

  resp = requests.post('https://api.travis-ci.com/auth/github',
           data = tokenRequest
         )

  if resp.status_code != 200: return

  # Get the actual token

  token = json.loads(resp.text)['access_token']

  # API Headers
  requestHeaders = {
      "User-Agent": "TravisActivate/1.0",
      "Authorization": "token \"" + token + "\"",
      "Accept": "application/vnd.travis-ci.2+json"
  }
  
  requestHeadersV3 = {
      "User-Agent": "TravisActivate/1.0",
      "Content-Type": "application/json",
      "Accept": "application/json",
      "Travis-API-Version": "3",
      "Authorization": "token " + token
  }

  # API Payload
  desiredSettings = {
      "settings": {
          "builds_only_with_travis_yml": True,
          "build_pushes": True,
          "build_pull_requests": True,
          "maximum_number_of_builds": 1
      }
  }
  
  buildRequest = {
      "request": {
          "branch": "master"
      }
  }

  buildRequest = {}

  # Get user ID
  userInfo = requests.get('https://api.travis-ci.com/user', headers = requestHeadersV3)
  userID   = userInfo.json()['id']

  repo = None
  repoID = None

  while repoID is None:
    # Cool-down
    if repo: time.sleep(2)

    # Sync user repos
    syncPost = requests.post('https://api.travis-ci.com/user/{}/sync'.format(userID), headers = requestHeadersV3)

    # Repo Slug
    repo_slug = '{}%2F{}'.format( org, repo_name )

    # Activate repo
    repo = requests.get('https://api.travis-ci.com/repo/{}'.format(repo_slug),
                         headers = requestHeadersV3)

    if repo.status_code == 200:
      repoID = repo.json()['id']

  # Activate repo
  requests.post('https://api.travis-ci.com/repo/{}/activate'.format(repoID),
                headers = requestHeadersV3,
                data = json.dumps(buildRequest))

  # Set settings
  requests.patch('https://api.travis-ci.com/repos/{}/settings'.format(repoID),
                 headers = requestHeaders,
                 data = json.dumps(desiredSettings))

  # Request a re-build
  requests.post('https://api.travis-ci.com/repo/{}/requests'.format(repoID),
                headers = requestHeadersV3,
                data = json.dumps(buildRequest))

#=========================================
# Initialize repos
#=========================================
def init_repos ( ):

  # Globals
  global group_lock
  global student_info
  global group_info
  global db_dirty
  global logger

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  logger.warning('--- STARTING AN INITIALIZATION PROCESS ---')

  #=======================================
  # Remove all repos and teams
  #=======================================

  # Delete all repos
  logger.warning('  * Deleting repositories:')
  for gid in xrange(1, 41):
    group_id = str(gid)
    group_name = 'lab-group{:02d}'.format( int( group_id ) )
    logger.warning('    - {}'.format(group_name))
    try:
      repo = course_org.get_repo( group_name )
    except:
      repo = None
    if repo: repo.delete()
    time.sleep(0.1)

  # Delete all teams
  logger.warning('  * Deleting teams:')
  for tid in xrange(1, 41):
    team_name = 'lab-group{:02d}'.format( tid )
    logger.warning('    - {}'.format(team_name))
    try:
      team = get_team( course_org, team_name )
    except:
      team = None
    if team: team.delete()
    time.sleep(0.1)

  # Remove all students
  logger.warning('  * Removing git usernames from organization:')
  students = generic_team.get_members()
  for student in students:
    if student.login != 'cbatten' and student.login != 'hawajkm':
      logger.warning('    - {}'.format(student.login))

      try:
        course_org.remove_from_members(student)
      except:
        pass

      try:
        course_org.remove_from_membership(student)
      except:
        pass

      try:
        course_org.remove_from_public_members(student)
      except:
        pass

    time.sleep(0.1)

  #=======================================
  # Recreate all structures
  #=======================================

  # Generate new teams
  logger.warning('  * Creating teams:')
  for tid in xrange(1, 41):
    team_name = 'lab-group{:02d}'.format( tid )
    logger.warning('    - {}'.format(team_name))
    team = course_org.create_team( team_name )
    team.edit( team_name, permission = 'push' )
    time.sleep(0.1)

  # Update teams
  for tid in xrange(1, 41):
    team_name = 'lab-group{:02d}'.format( tid )
    groups_teams[team_name] = get_team( course_org, team_name )
    time.sleep(0.1)

  # Create an authorization token for github
  # trails = 0
  # auth = None
  # while auth == None and trails < 10:
  #   trails = trails + 1
  #   try:
  #     key_name = 'temp_key_{:06d}'.format(randint(0, 999999))
  #     auth = github_obj.get_user().create_authorization(scopes=['repo', 'user'], note=key_name)
  #   except:
  #     auth = None

  # # Hopefully we got a valid key
  # assert auth

  # Generate new repos
  logger.warning('  * Creating repositories:')
  for gid in xrange(1, 41):
    group_id = str(gid)
    group_name = 'lab-group{:02d}'.format( int( group_id ) )
    logger.warning('    - {}'.format(group_name))
    repo = course_org.create_repo( group_name, private = True )
    team = groups_teams[group_name]
    team.edit( group_name, permission='push' )
    team.add_to_repos( repo )
    update_group_description( group_id )
    init_repo_readme( repo.name, group_id)
    #hawajkm: This is experimental; please! do not uncomment
    #activate_travisCI( course_org.login, repo.name, auth )

    # yugan: grant 'admins', 'graders' and 'staff' the access to the repo
    # 'admins' ID: 2499788
    # 'graders' ID: 2515605
    # 'staff' ID: 1699381
    course_org.get_team( 2499788 ).add_to_repos( repo )
    course_org.get_team( 2515605 ).add_to_repos( repo )
    course_org.get_team( 1699381 ).add_to_repos( repo )

    time.sleep(0.1)

  # Delete authorization token
  # if auth:
  #   auth.delete()

  # All is well ...
  ret = 0
  msg = 'All repos were initialized correctly.'

  return ( ret, msg )

#=========================================
# Create a group
#=========================================
def create_group ( netid ):

  # Globals
  global group_lock
  global student_info
  global group_info
  global db_dirty
  global sync_db

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Return message and code
  ret = -1
  msg = ''

  # Does the student have a group already?
  # If so, deny creating a new group
  if student_info[netid]['group']:
    if   student_info[netid]['group'][0] == 'c':
      ret = -15
      msg =  'You are already part of group {}.'.format( student_info[netid]['group'][1] ) + \
            ' Plese, leave any group before attempting creating a new group.'

    elif student_info[netid]['group'][0] == 'p':
      ret = -15
      msg =  'You have a join request for group {}.'.format( student_info[netid]['group'][1] ) + \
            ' Plese, cancel your join request before attempting creating a new group.'

    else:
      ret = -15
      msg =  'Your group record is corrupted.' + \
            ' Please, contact the course\'s staff to fix this.'

  else:
    # Acquire a lock
    group_lock.acquire()

    # Find an empty group
    group_id = find_empty_group( student_info[netid]['status'] )

    if group_id == None:
      ret = -16
      msg =  'No groups are available now.' + \
            ' Try again later or contact the course\'s staff.'

    else:
      github_user = student_info[netid]['github_id']
      github_id = github_obj.get_user( github_user )

      if course_org.has_in_members( github_id ):

        if group_id[0] == 'a':

          #==================
          # Auditing students
          #==================

          group_name = 'audit-group{:02d}'.format( int( group_id[1:] ) )

          # Create the team
          team = course_org.create_team( group_name )
          team.add_to_members( github_id )

          # Create the repo
          repo = course_org.create_repo( group_name, private = True )
          team.edit( group_name, permission = 'push' )
          team.add_to_repos( repo )

          student_info[netid]['group'] = ['c', group_id]

          ret = 0
          msg = 'Group "{}" was successfully created.'.format( group_id )

        else:

          #==================
          # Graded students
          #==================

          team_name = 'lab-group{:02d}'.format( int( group_id ) )
          team = groups_teams[team_name]

          team.add_to_members( github_id )

          student_info[netid]['group'] = ['c', group_id]

          ret = 0
          msg = 'Group "{}" was successfully created.'.format( group_id )


        # Update Groups
        group_info[group_id] = { 'members'      : [ netid ],
                                 'pending_reqs' : [       ] }

        # Update github description
        update_group_description( group_id )

        # Database needs update
        db_dirty = True

        # Signal update thread
        sync_db.set()

      else:
        # Properly didn't accept invitation
        ret = -19
        msg =  'It seems that you did not accept the invitation for GitHub ID' + \
              ' "{}".\nPlease, accept the invitation and try again later.'.format( github_user )

    # Release lock
    group_lock.release()

  # Return
  return ( ret, msg )

#=========================================
# Leave a group
#=========================================
def leave_group ( netid ):

  # Globals
  global group_lock
  global student_info
  global group_info
  global db_dirty
  global sync_db
  global executable_path

  global github_obj
  global github_token
  global course_org
  global generic_team
  global groups_teams

  # Return message and code
  ret = -1
  msg = ''

  # Make sure the student have a group
  if student_info[netid]['group']:
    # Acquire a lock
    group_lock.acquire()

    # Get current group
    group_status = student_info[netid]['group']

    if group_status[0] == 'c':
      group_id = group_status[1]

      team_name = 'lab-group{:02d}'.format( int( group_id ) )
      team = groups_teams[team_name]

      github_id = github_obj.get_user( student_info[netid]['github_id'] )
      team.remove_from_members( github_id )

      # Clone for the student
      # Create a token
      # trails = 0
      # auth = None
      # while auth == None and trails < 10:
      #   trails = trails +  1
      #   try:
      #     key_name = 'temp_key_{:06d}'.format(randint(0, 999999))
      #     auth = github_obj.get_user().create_authorization(scopes=['repo', 'user'], note='temp_key')
      #   except:
      #     auth = None

      # Get latest commit on the repo
      repo   = course_org.get_repo( team_name )
      commit = repo.get_commits()[0].sha[0:11]

      # Get new repo
      shadow_name = team_name + "_" + commit
      try:
        shadow_repo = course_org.get_repo( shadow_name )
      except:
        course_org.create_repo( shadow_name, private = True )
        shadow_repo = course_org.get_repo( shadow_name )

      # Copy the repo
      gh_uname = github_obj.get_user().login
      gh_pwd   = github_token
      org_name = course_org.login
      src_repo = team_name
      dst_repo = shadow_name

      gh_copy = executable_path + '/ece4750-copy-repo'
      cmd     = gh_copy + ' {} {} {} {} {}'.format( gh_uname, gh_pwd  ,
                                                    org_name, src_repo,
                                                    dst_repo,         )
      subshell( cmd )

      # Add user
      shadow_repo.add_to_collaborators( github_id )

      # Remove authorization token
      # auth.delete()

      # Update Group
      while netid in group_info[group_id]['members']:
        group_info[group_id]['members'].remove( netid )

      # All is well ...
      ret = 0
      msg = 'You were removed from group "{}" successfully.'.format( group_id )

      # Update github description
      update_group_description( group_id )

    elif group_status[0] == 'p':
      group_id = group_status[1]

      # Update Group
      while netid in group_info[group_id]['pending_reqs']:
        group_info[group_id]['pending_reqs'].remove( netid )

      # All is well ...
      ret = 0
      msg = 'Your joining request was removed from group "{}" successfully.'.format( group_id )

    else:
      # All is well ...
      ret = 0
      msg = 'Your corrupted group record was reset successfully.'

    # Reset the student's group status
    student_info[netid]['group'] = None

    if len(group_info[group_id]['members']) == 0:
      # Remove group from pending requests
      for pending_netid in group_info[group_id]['pending_reqs']:
        student_info[pending_netid]['group'] = None

      # Remove the group
      del group_info[group_id]

    # Database needs update
    db_dirty = True

    # Signal update thread
    sync_db.set()

    # Release lock
    group_lock.release()

  else:
    ret = -18
    msg =  'You are not currently part of any group' + \
          ' nor do you have a pending joining request' + \
          ' This request will be ignored!'

  # Return
  return ( ret, msg )

#=========================================
# Join a group
#=========================================
def join_group ( netid, group_id ):

  # Globals
  global group_lock
  global student_info
  global group_info
  global db_dirty
  global sync_db

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Return message and code
  ret = -1
  msg = ''

  # Fail safe
  group_id = str( group_id )

  # Does the student have a group already?
  # If so, deny joining another group
  if student_info[netid]['group']:
    if   student_info[netid]['group'][0] == 'c':
      ret = -15
      msg =  'You are already part of group {}.'.format( student_info[netid]['group'][1] ) + \
            ' Plese, leave your group before attempting joining another group.'

    elif student_info[netid]['group'][0] == 'p':
      ret = -15
      msg =  'You have a join request for group {}.'.format( student_info[netid]['group'][1] ) + \
            ' Plese, cancel your join request before attempting joining another group.'

    else:
      ret = -15
      msg =  'Your group record is corrupted.' + \
            ' Please, contact the course\'s staff to fix this.'
  else:
    # Check if the group exists
    if group_id in group_info.keys():
      # Check if group is still alive
      if len(group_info[group_id]['members']) > 0:
        # Acquire a lock
        group_lock.acquire()

        # All we do is place a pending joining request
        group_info[group_id]['pending_reqs'].append( netid )

        # Keep track ...
        student_info[netid]['group'] = ['p', group_id]

        # All is well ...
        ret = 0
        msg = 'Your request to join group "{}" is pending approval.'.format( group_id )

        # Dirty DB
        db_dirty = True

        # Signal update thread
        sync_db.set()

        # Done
        group_lock.release()

      else:
        ret = -215
        msg = 'Group does not exist'

    else:
      ret = -215
      msg = 'Group does not exist'

  # Return
  return ( ret, msg )

#=========================================
# Return pending join-requests
#=========================================
def pending_group ( netid ):

  # Globals
  global group_lock
  global student_info
  global group_info

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Return message and code
  ret = -1
  msg = ''

  # Make sure the student have a group
  if student_info[netid]['group']:
    # Acquire a lock
    group_lock.acquire()

    # Get current group
    group_status = student_info[netid]['group']

    if group_status[0] == 'c':
      group_id = group_status[1]

      # All is well ...
      ret = 0
      msg = 'Pending join-requests for group {}: {}'\
            .format( group_id, ', '.join(group_info[group_id]['pending_reqs']) )

    elif group_status[0] == 'p':
      group_id = group_status[1]

      # All is well ...
      ret = -218
      msg =   'Your joining request to group "{}" is still pending.'.format( group_id ) + \
            '\nYou cannot view group\'s administrative tasks until you are approved.'

    else:
      # All is well ...
      ret = -219
      msg = 'Your group record is corrupted.'

    # Release lock
    group_lock.release()

  else:
    ret = -18
    msg =  'You are not currently part of any group' + \
          ' nor do you have a pending joining request' + \
          ' This request will be ignored!'

  # Return
  return ( ret, msg )

#=========================================
# Approve pending join-requests
#=========================================
def approve_group ( netid, o_netid ):

  # Globals
  global group_lock
  global student_info
  global group_info
  global db_dirty
  global sync_db

  global github_obj
  global course_org
  global generic_team
  global groups_teams

  # Return message and code
  ret = -1
  msg = ''

  # Make sure the student have a group
  if student_info[netid]['group']:
    # Acquire a lock
    group_lock.acquire()

    # Get current group
    group_status = student_info[netid]['group']

    if group_status[0] == 'c':
      group_id = group_status[1]

      # Make sure that the o_netid has a pending request
      if o_netid in group_info[group_id]['pending_reqs']:

        # Make sure o_netid has correct records
        o_group_status = None
        if o_netid in student_info:
          o_group_status = student_info[o_netid]['group']

        if o_group_status and o_group_status[0] == 'p' and o_group_status[1] == group_id:

          # Make sure github ID set properly
          if student_info[o_netid]['github_id']:
            o_github_user = student_info[o_netid]['github_id']
            o_github_id   = github_obj.get_user( o_github_user )

            # Make sure o_netid has accepted invitation to the orginization
            if course_org.has_in_members( o_github_id ):

              group_name = 'lab-group{:02d}'.format( int( group_id ) )

              # Add user
              try:
                groups_teams[group_name].add_to_members( o_github_id )

                student_info[o_netid]['group'][0] = 'c'
                group_info[group_id]['members'].append( o_netid )

                while o_netid in group_info[group_id]['pending_reqs']:
                  group_info[group_id]['pending_reqs'].remove( o_netid )

                # Dirty DB
                db_dirty = True

                # Signal update thread
                sync_db.set()

                # Update github description
                update_group_description( group_id )

                # All is well ...
                ret = 0
                msg = 'Joining request for NetID {} has been accepted successfully'\
                      .format( o_netid )

              except:
                # All is well ...
                ret = -318
                msg = 'Adding NetID {}\'s GitHub ID {} to group {} failed.'\
                      .format( o_netid, o_github_user, group_id )

            else:
              ret = -316
              msg = 'NetID {} has not accepted invitation to course orginization.'.format( o_netid )

          else:
            ret = -313
            msg = 'Inconsistant database.'

        else:
          ret = -313
          msg = 'Inconsistant database.'

      else:
        ret = -310
        msg = 'NetID {} has no pending join-request to group {}.'.format( o_netid, group_id )

    elif group_status[0] == 'p':
      group_id = group_status[1]

      # All is well ...
      ret = -218
      msg =   'Your joining request to group "{}" is still pending.'.format( group_id ) + \
            '\nYou cannot execute group\'s administrative tasks until you are approved.'

    else:
      # All is well ...
      ret = -219
      msg = 'Your group record is corrupted.'

    # Release lock
    group_lock.release()

  else:
    ret = -18
    msg =  'You are not currently part of any group' + \
          ' nor do you have a pending joining request' + \
          ' This request will be ignored!'

  # Return
  return ( ret, msg )

#=========================================
# Get team object from name
#=========================================
def get_team( org, team_name ):

  # Get all teams
  teams = org.get_teams()

  # Filter
  q_teams = [x for x in teams if x.name == team_name]

  # Do we have a match
  team = None
  if len(q_teams) > 0: team = q_teams[0]

  # Finished
  return team

#=========================================
# Setup the server
#=========================================
def server_setup ( username, pwd ):

  # Globals
  global reset_db
  global db_dirty
  global server_started
  global sync_db

  global github_obj
  global github_token
  global course_org
  global generic_team
  global groups_teams

  # Return
  ret = -1
  msg = ''

  try:
    tmp_github_obj = Github( pwd, user_agent='PyGithub' )
    tmp_github_token = pwd
    # tmp_github_obj = Github( username, pwd, user_agent='PyGithub' )
    tmp_course_org = tmp_github_obj.get_organization( 'cornell-ece4750' )
    tmp_teams      = tmp_course_org.get_teams()
    tmp_course_org.get_members()

    # WORKED
    ret = 0
    msg = 'Server was successfully started and properly setup.'

    # Swap
    github_obj = tmp_github_obj
    github_token = tmp_github_token
    course_org = tmp_course_org

    # Parse teams :)
    groups_teams = {}
    for team in tmp_teams:
      if   team.name      == 'students':
        generic_team = team
      elif team.name[0:9] == 'lab-group':
        groups_teams[team.name] = team

    # :)
    server_started = True
    if update_db:
      # If an update is pending
      db_dirty = True

      # Signal update thread
      sync_db.set()


  except GithubException as e:
    ret = -64
    msg =  'GitHub could NOT connect properly.' + \
         '\nCheck the provided username/password as well as premissions.'

  # Finish
  return ( ret, msg )

#=========================================
# Get students list as a dictionary
#=========================================
def get_students_dict ( succinct=False ):

  # Globals
  global group_info
  global student_info

  # Return
  ret =  0
  msg = ''

  students_dict = {}
  students      = student_info.keys()

  i = 0
  for i in xrange( len( students ) ):

    students_dict[i] = students[i]

  msg = ''

  if not succinct:
    msg += 'Groups JSON:\n\n'

  json_str = json.dumps( students_dict, sort_keys = True          ,
                         indent = 2   , separators= ( ',', ': ' ) )

  msg += '{}'.format( json_str )


  # Finish
  return ( ret, msg )

#=========================================
# Get groups as a dictionary
#=========================================
def get_groups_dict ( succinct=False ):

  # Globals
  global group_info

  # Return
  ret =  0
  msg = ''

  group_dict = {}

  for group_id in group_info:

    group_dict[group_id] = group_info[group_id]['members']

  msg = ''

  if not succinct:
    msg += 'Groups JSON:\n\n'

  json_str = json.dumps( group_dict, sort_keys = True          ,
                         indent = 2, separators= ( ',', ': ' ) )

  msg += '{}'.format( json_str )

  # Finish
  return ( ret, msg )

#=========================================
# Resetting the database
#=========================================
def reset_database ():

  # Globals
  global reset_db
  global db_dirty
  global sync_db

  # Return
  ret = -1
  msg = ''

  # Signal intentions
  reset_db = True

  # Report
  ret = 0
  msg =   'Database reset was scheduled successfully' + \
        '\nThe request will be executed during the next database sync'

  # Database is super dirty
  db_dirty = True

  # Signal update thread
  sync_db.set()

  # Finish
  return ( ret, msg )

#=========================================
# Update the database
#=========================================
def update_database ( force = False ):

  # Globals
  global update_db
  global force_update
  global db_dirty
  global sync_db

  # Return
  ret = -1
  msg = ''

  # Add a pending request for update
  update_db = True
  force_update = force

  # Report
  ret = 0
  msg =   'Database update was scheduled successfully' + \
        '\nThe request will be executed during the next database sync'


  # Database is super dirty
  db_dirty = True

  # Signal update thread
  sync_db.set()

  # Finish
  return ( ret, msg )

#=========================================
# Update assignments
#=========================================
def refresh_assignments ():

  # Globals
  global update_db
  global refresh_db
  global force_update
  global db_dirty
  global sync_db

  # Return
  ret = -1
  msg = ''

  # Add a pending request for update
  refresh_db = True

  # Report
  ret = 0
  msg =   'Assignments database update was scheduled successfully' + \
        '\nThe request will be executed during the next database sync'

  # Signal update thread
  sync_db.set()

  # Finish
  return ( ret, msg )

#-------------------------------------------------------------------------
# Execute commands routine
#-------------------------------------------------------------------------

def execute_command( netid, cmd, args ):

  # Globals
  global student_info
  global superusers
  global server_started
  global server_shutdown

  # Check if we have a valid netid
  ret = -1
  msg = ''
  if netid == None or netid == '':
    ret = 1
    msg = 'Invalid NetID'
    return ( ret, msg )

  # Gather basic information about the netid
  netid_exists = ( netid in student_info )
  netid_su     = ( netid in superusers   )
  group        = None
  github_id    = None
  if netid_exists:
    github_id = student_info[netid]['github_id']
    group     = student_info[netid]['group' ]

  # Execute the command
  serviced = False

  # Admin specific commands
  if cmd == 'server':
    serviced = True
    if netid_su:
      # Reset the database
      if   args[0] == 'reset':
        ret, msg = reset_database()

      # Update the database
      # hawajkm: Keeping this for now!
      elif args[0] == 'update':
        force = False
        if len(args) > 1:
          force = args[1] == 'force'
        ret, msg = update_database( force )

      # Setup the server
      elif args[0] == 'setup':
        if len(args[1:]) >= 2:
          ret, msg = server_setup( args[1], args[2] )
        else:
          ret = -7
          msg = 'Not enough arguments supplied for "server setup"'

      # Shutdown the server gracefully
      elif args[0] == 'quit':
        # Signal a shutdown
        server_shutdown = True

        ret = 0
        msg =   'Shutting down the server.' + \
              '\nPending requests followed by a database sync will be execuetd'

      # Initialize group repos
      elif args[0] == 'init_repos':
        if server_started:
          ret, msg = init_repos()
        else:
          ret = -10
          msg = 'Server needs to be setup for this operation'

      # Not defined
      else:
        ret = 2
        msg = 'Operation "{}" is not defined as a server command.'.format( args[0] )

    else:
      # NetID is not in the database
      ret = -5
      msg = 'Your are not authorized to perform the requested operation'

  # Admin specific commands
  if cmd == 'students':
    serviced = True
    if netid_su:
      # Update the database
      if   args[0] == 'update':
        force = False
        if len(args) > 1:
          force = args[1] == 'force'
        ret, msg = update_database( force )

      # Get a dictionary for groups
      elif args[0] == 'groups':
        # Get the groups assignments
        ret, msg = get_groups_dict( succinct=False )

      # Get a watered-down dictionary for groups
      elif args[0] == 'ugroups':
        # Get the groups assignments
        ret, msg = get_groups_dict( succinct=True  )

      # Get a students list
      elif args[0] == 'list':
        # Get list numbered from 0 to n-1
        ret, msg = get_students_dict( succinct=False )

      # Get a students list
      elif args[0] == 'ulist':
        # Get list numbered from 0 to n-1
        ret, msg = get_students_dict( succinct=True )

      # Assignments
      elif args[0] == 'update-assignments':
        ret, msg = refresh_assignments()

      # Update fields
      # Expermintal
      elif args[0] == 'set-all':
        if len(args[1:]) >= 2:
          ret, msg = set_database_field( None, args[1], args[2] )
        else:
          ret = -7
          msg = 'Not enough arguments supplied for "set-database-field"'

      elif args[0] == 'set':
        if len(args[1:]) >= 3:
          ret, msg = set_database_field( args[1], args[2], args[3] )
        else:
          ret = -7
          msg = 'Not enough arguments supplied for "set-database-field"'

      # Peform an action on behalf a student
      elif args[0] == 'dofor':
        if len(args[1:]) >= 2:
          ret, msg = execute_command( args[1], args[2], args[3:] )
        else:
          ret = -7
          msg = 'Not enough arguments supplied for "set-database-field"'


      # Not defined
      else:
        ret = 2
        msg = 'Operation "{}" is not defined as a server command.'.format( args[0] )

    else:
      # NetID is not in the database
      ret = -5
      msg = 'Your are not authorized to perform the requested operation'

  # If not an admin command,
  # don't do anything if server wasn't started properly
  if not serviced and not server_started:
    ret = -128
    msg =   'Server was NOT started properly.' + \
          '\nTry again later or contact the course\'s staff'
    return ( ret, msg )

  # STATUS ENQUIRY
  if cmd == 'status':
    serviced = True
    if netid_exists:
      ret, msg = get_student_status( netid, github_id, group )
    else:
      # NetID is not in the database
      ret = 1
      msg = 'Your NetID {} is not in our database.'.format( netid ) + \
            '\nMake sure you are properly enrolled in the class.' + \
            '\nEmail the course\'s staff to fix this issue.'

  # GitHub stuff
  if cmd == 'github':
    serviced = True
    if netid_exists:
      if args[0] == 'set':
        ret, msg = assign_github_id( netid, args[1] )
      else:
        ret = 2
        msg = 'Operation "{}" is not defined as a GitHub command.'.format( args[0] )
    else:
      # NetID is not in the database
      ret = 1
      msg = 'Your NetID {} is not in our database.'.format( netid ) + \
            '\nMake sure you are properly enrolled in the class.' + \
            '\nEmail the course\'s staff to fix this issue.'

  # Group Managment
  if cmd == 'group':
    serviced = True
    if netid_exists and github_id:
      if   args[0] == 'create':
        ret, msg = create_group( netid )
      elif args[0] == 'leave':
        ret, msg = leave_group( netid )
      elif args[0] == 'join':
        if len( args ) < 2:
          ret = -2
          msg = 'Group ID is missing! Incomplete command.'
        else:
          if len(args[1]) > 0:
            group_id = args[1]
            ret, msg = join_group( netid, group_id )
          else:
            ret = -3
            msg = 'Invalid group ID was provided. Make sure that group ID is an integer.'
      elif args[0] == 'pending':
        ret, msg = pending_group( netid )
      elif args[0] == 'approve':
        ret, msg = approve_group( netid, args[1] )
      else:
        ret = 2
        msg = 'Operation "{}" is not defined as a GitHub command.'.format( args[0] )
    elif netid_exists:
      # NetID is not in the database
      ret = 10
      msg = 'You have not set a GitHub ID.' + \
            '\nSet a proper GitHub ID and accept the invitation to ECE4750 orginization.'
    else:
      # NetID is not in the database
      ret = 1
      msg = 'Your NetID {} is not in our database.'.format( netid ) + \
            '\nMake sure you are properly enrolled in the class.' + \
            '\nEmail the course\'s staff to fix this issue.'

  # What if command is not defined?
  if not serviced:
    ret = -1
    msg = 'Command "{}" is not defined.'.format( cmd )

  return ( ret, msg )

#-------------------------------------------------------------------------
# Main servicing logic
#-------------------------------------------------------------------------

def service_request( client, conn_point ):

  # Retrieve actual arguments
  addr = conn_point[0]
  port = conn_point[1]

  # Get the netid
  netid = retrieve_netid( addr, port )

  # Read the request string
  req_raw = recv_data( client )

  # We return a message and an exit code to the requester
  ret = -1
  msg = ''

  # Do we even have a request :) ?
  if req_raw and netid:

    # Count us in as updaters
    admit_updater()

    # Service the request
    # request will be in the format of "REQUEST\nARGUMENT_1\n ..."
    req  = req_raw.split('\n')

    # Switch on the request
    cmd  = req[0 ]
    args = req[1:]
    ret, msg = execute_command( netid, cmd, args )

    # We are done! :)
    release_updater()

  elif not netid:

    # Couldn't authenticate the username
    ret = -1
    msg = 'Could not authenticate the NetID of the requester.'

  else:

    # Invalid request
    ret = -1
    msg = 'Invalid request.'

  # Return response
  response = '{}\n{}'.format( ret, msg )
  send_data( client, response, False )

  # Cleanly close connection
  client.close()

#-------------------------------------------------------------------------
# Handle termination signal
#-------------------------------------------------------------------------

def sigint_handler (signal_num, frame):
  global server_shutdown
  global sync_db
  global logger

  print('')

  logger.warning( 'Recieved signal ({}) ...'.format( signal_num ) )
  logger.info( 'Server shutting down gracefully' )

  # Force a database sync
  server_shutdown = True

  # Signal update thread
  sync_db.set()

 
signal.signal(signal.SIGINT , sigint_handler)
signal.signal(signal.SIGTERM, sigint_handler)

#-------------------------------------------------------------------------
# Dispatching logic
#-------------------------------------------------------------------------
# hawajkm: Instead of reading files, we actually have a proper inter-
#          process communication through TCP/IP

# Announce the start
logger.info( 'Starting the server ...' )

# Where are we? :)
logger.info( 'Server path is set to {}'.format( executable_path ) )

# Thread for updating the DB on the disk
threading.Thread(target = sync_database).start()

sock = socket.socket( socket.AF_INET, socket.SOCK_STREAM )
sock.setsockopt( socket.SOL_SOCKET, socket.SO_REUSEADDR, 1 )

address = ( '', gConfigs.server_port )

logger.info ( 'Listening to incoming connections at port {}'.format( gConfigs.server_port ) )

try:

  sock.bind(address)
  sock.listen(5)

except:

  print('ERROR: Cannot bind/listen to assigned port')
  quit( -1 )

# Time-out
sock.settimeout(1)

while not server_shutdown:

  try:
    # Accept incoming connections
    client, address = sock.accept()

    # Wait for any stalling requests
    while stall_requests :
      pass

    # Dispatch
    client.settimeout(60)
    threading.Thread(target = service_request, args = (client, address)).start()

  except:
    pass
