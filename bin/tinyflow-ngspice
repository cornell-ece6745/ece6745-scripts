#!/usr/bin/env python3
#=========================================================================
# Wrapper Python script for ngspice simulation and characterization
#=========================================================================
# Authors : Parker Schless
# Date    : January 2026
# 
# Note: Claude Code was used to help generate this script

from datetime import datetime
from pathlib import Path
from schema import Schema, And, Or, Regex, SchemaError
import argparse
import jinja2
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend before importing pyplot
import matplotlib.pyplot as plt
import numpy as np
import os
import re
import subprocess
import sys

class TinyFlowSchema:
  """Schema validator for TinyFlow ngspice arguments."""

  PIN_SPEC_PATTERN = r'^([A-Za-z_][A-Za-z0-9_]*):([01])(-[01])*$'
  CLOAD_PATTERN = r'^(\d+\.?\d*|\.\d+)(a|f|p|n|u|m)?$'

  def __init__(
    self,
    spice_path=None
  ):
    self._spice_path = spice_path
    self._cell_info = {}  # Will be populated during validation

    self._schema = Schema(And(
      {
        'cell': str,
        'cload': And(str, Regex(self.CLOAD_PATTERN),
                     error='invalid cload, expected decimal with optional unit suffix (a, f, p, n, u, m)'),
        'inputs': str,
        'spice': And(str, self._validate_spice_file,
                     error='spice file does not exist')
      },
      self._validate_cell_exists,
      self._validate_inputs_for_cell
    ))

  def _parse_spice_cells(
    self,
    spice_path
  ):
    """
    Parse a SPICE file and extract cell names and their pin information.

    Handles two formats:
    1. Named pins: .SUBCKT NOR2X1 A B Y VDD VSS
    2. Numbered pins with comments:
      * cell AOI21X1
      * pin B
      * pin C
      * pin A
      * pin Y
      * pin VDD
      * pin VSS
      .SUBCKT AOI21X1 1 2 3 4 7 8

    Returns:
      dict: {cell_name: [ordered_pins_excluding_VDD_VSS], ...}
    """
    path = Path(spice_path)
    if not path.is_absolute():
      path = Path.cwd() / path

    if not path.exists():
      return {}

    content = path.read_text()
    lines = content.splitlines()

    cells = {}

    i = 0
    while i < len(lines):
      line = lines[i].strip()

      # Look for .SUBCKT lines
      if line.upper().startswith('.SUBCKT'):
        parts = line.split()
        if len(parts) >= 2:
          cell_name = parts[1]
          subckt_tokens = parts[2:]  # Everything after cell name

          # Check if tokens are numbered (all digits) or named
          all_numeric = all(token.isdigit() for token in subckt_tokens if token)

          if all_numeric and subckt_tokens:
            # Numbered pins - look for * pin comments above
            pin_names = []
            j = i - 1
            while j >= 0:
              prev_line = lines[j].strip()
              if prev_line.startswith('* pin '):
                pin_name = prev_line[6:].strip()
                pin_names.insert(0, pin_name)  # Insert at beginning since we're going backwards
                j -= 1
              elif prev_line.startswith('* cell '):
                break
              elif prev_line == '' or prev_line.startswith('*'):
                j -= 1
              else:
                break

            # Filter out VDD and VSS, keep order
            ordered_pins = [p for p in pin_names if p.upper() not in ('VDD', 'VSS')]
            cells[cell_name] = ordered_pins
          else:
            # Named pins directly in .SUBCKT line
            ordered_pins = [p for p in subckt_tokens if p.upper() not in ('VDD', 'VSS')]
            cells[cell_name] = ordered_pins

        i += 1
      else:
        i += 1

    return cells

  def _validate_spice_file(
    self,
    spice_path
  ):
    """Validate that the spice file exists and parse cell info."""
    path = Path(spice_path)
    if not path.is_absolute():
      path = Path.cwd() / path
    if not path.exists():
      return False
    # Parse cell info from the spice file
    self._cell_info = self._parse_spice_cells(spice_path)
    return True

  def _validate_cell_exists(
    self,
    data
  ):
    """Validate that the cell exists in the spice file."""
    cell = data['cell']
    if cell not in self._cell_info:
      available_cells = list(self._cell_info.keys())
      raise SchemaError(f"cell '{cell}' not found in spice file, available cells: {available_cells}")
    return data

  def _validate_inputs_for_cell(
    self,
    data
  ):
    """Validate inputs string format and required pins for the cell type."""
    cell = data['cell']
    inputs_str = data['inputs']
    # Get pins from parsed cell info, excluding output pin 'Y'
    cell_pins = self._cell_info.get(cell, [])
    expected_pins = set(p for p in cell_pins if p.upper() != 'Y')

    # Handle cells with no inputs (TIEHI/TIELO)
    if not expected_pins:
      if inputs_str and inputs_str.strip():
        raise SchemaError(f"{cell} requires no input pins")
      return data

    # Cells that require inputs
    if not inputs_str or not inputs_str.strip():
      raise SchemaError(f"{cell} requires input pins {sorted(expected_pins)}")

    # Validate each pin specification
    provided_pins = set()
    pin_schema = Schema(Regex(self.PIN_SPEC_PATTERN))

    for pin_spec in inputs_str.split(';'):
      try:
        pin_schema.validate(pin_spec)
      except SchemaError:
        raise SchemaError(f"malformed input '{pin_spec}', expected format 'PIN:val-val-...' where val is 0 or 1, pin specs separated by ';'")
      pin = pin_spec.split(':')[0]
      if pin in provided_pins:
        raise SchemaError(f"duplicate pin '{pin}' in inputs")
      provided_pins.add(pin)

    # Check required pins match provided pins
    if provided_pins != expected_pins:
      missing = expected_pins - provided_pins
      extra = provided_pins - expected_pins
      if missing:
        raise SchemaError(f"{cell} missing pins: {', '.join(sorted(missing))}")
      if extra:
        raise SchemaError(f"{cell} unexpected pins: {', '.join(sorted(extra))}")

    # Validate all pins have equal number of values
    step_counts = []
    for pin_spec in inputs_str.split(';'):
      sequence = pin_spec.split(':')[1]
      values = sequence.split('-')
      step_counts.append(len(values))
    if len(set(step_counts)) > 1:
      raise SchemaError("all input pins must have equal number of values")

    return data

  def validate(
    self,
    args
  ):
    """Validate argparse Namespace against schema."""
    return self._schema.validate(vars(args))

  def get_cell_pins(
    self,
    cell_name
  ):
    """Get the ordered list of pins for a cell (excluding VDD/VSS)."""
    return self._cell_info.get(cell_name, [])

class TinyFlowNgspice:
  """TinyFlow ngspice simulation and characterization wrapper."""

  def __init__(
    self
  ):
    self.args = None
    self.tb_data = {}
    self.output_lines = []

  def _log(
    self,
    line=''
  ):
    """Print line to console and store for file output."""
    print(line)
    self.output_lines.append(line)

  def parse_args(
    self
  ):
    """Parse command line arguments."""

    parser = argparse.ArgumentParser(
      description='TinyFlow ngspice simulation and characterization wrapper'
    )

    parser.add_argument(
      '--cell',
      type=str,
      required=True,
      help='Type of standard cell to simulate (must exist in spice file)'
    )

    parser.add_argument(
      '--cload',
      type=str,
      default='0f',
      help='Load capacitance with units (e.g., "10f" for 10 femtofarads)'
    )

    parser.add_argument(
      '--spice',
      type=str,
      required=True,
      help='Path to spice netlist file (absolute or relative to cwd)'
    )

    parser.add_argument(
      '--inputs',
      type=str,
      default='',
      help='Input pin transitions'
    )

    self.args = parser.parse_args()

    # Validate arguments against schema
    try:
      schema = TinyFlowSchema()
      schema.validate(self.args)
    except SchemaError as e:
      print(f"Error: {e}", file=sys.stderr)
      sys.exit(1)

    # Set testbench data
    self.tb_data['date'] = datetime.now().strftime('%B %Y')
    self.tb_data['cell'] = self.args.cell
    self.tb_data['cload'] = self.args.cload
    self.tb_data['output_basename'] = self._get_output_basename()
    # Get ordered pins from spice file for circuit instantiation
    self.tb_data['cell_pins'] = schema.get_cell_pins(self.args.cell)
    
    skywater_spice = os.environ.get('SKYWATER_130NM_SPICE', '')
    self.tb_data['tech_lib_path'] = f'{skywater_spice}/libs.tech/ngspice/sky130.lib.spice'

    # Create output directory
    self.results_dir = Path.cwd() / 'ngspice-results'
    self.results_dir.mkdir(exist_ok=True)
    self.output_dir = self.results_dir / self.tb_data['output_basename']
    self.output_dir.mkdir(exist_ok=True)
    self.tb_data['output_dir'] = str(self.output_dir)

    # Parse inputs string and generate stimuli
    (
        self.tb_data['input_stimuli'],
        self.tb_data['sim_time'],
    ) = self._parse_inputs()

  def _get_output_basename(
    self
  ):
    """Convert inputs string to filename-safe suffix with leading dash.

    Example: 'A:0-1-0;B:1-0-1' -> '-A_0_1_0_B_1_0_1'
    Returns empty string if no inputs.
    """

    if not self.args.inputs:
      basename_inputs_str = ''
    else:
      basename_inputs_str = '-' + self.args.inputs.replace('-', '_').replace(':', '_').replace(';', '-')

    # Get spice file stem (filename without extension)
    spice_stem = Path(self.args.spice).stem

    return (
      f'{self.args.cell}-'
      f'{self.args.cload}-'
      f'{spice_stem}'
      f'{basename_inputs_str}'
    )

  def _parse_inputs(
    self
  ):
    """
    Parse validated inputs string and generate PWL stimuli dictionary and sim time.

    Note: Input validation is performed by _validate_args() before this method is called.

    Format: "A:0-1-0;B:0-1-1" where:
    - Character before ':' is the input pin name
    - Values after ':' separated by '-' are the voltage sequence (0 or 1)
    - Each step is 2ns apart

    Returns:
      tuple: (input_stimuli dict, sim_time string)
    """

    cell = self.args.cell

    # Handle cells with no inputs (e.g., TIEHI/TIELO)
    if not self.args.inputs or not self.args.inputs.strip():
      return {}, '2ns'

    input_stimuli = {}
    step_counts = []
    initial_values = {}  # Store first value of each input for output calculation

    # Parse each input pin's sequence (already validated by _validate_args)
    for pin_spec in self.args.inputs.split(';'):
      pin, sequence = pin_spec.split(':')
      values = sequence.split('-')

      initial_values[pin] = int(values[0])  # Store first value
      step_counts.append(len(values))

      pwl_parts = []
      prev_voltage = None

      for i, val in enumerate(values):
        voltage = 'SUPPLY' if val == '1' else '0'
        time_ns = i * 2
        time_str = f'{time_ns}n' if i > 0 else '0'

        if i == 0:
          # First value: set initial voltage at t=0
          pwl_parts.append(f'0 {voltage}')
        elif prev_voltage != voltage:
          # Transition: add both old and new voltage at same timestep
          pwl_parts.append(f'{time_str} {prev_voltage}')
          pwl_parts.append(f'{time_str} {voltage}')
        else:
          # No transition: add hold point at this timestep
          pwl_parts.append(f'{time_str} {voltage}')

        prev_voltage = voltage

      # Add final hold point at end of simulation window
      final_time_ns = len(values) * 2
      pwl_parts.append(f'{final_time_ns}n {prev_voltage}')

      input_stimuli[pin] = ' '.join(pwl_parts)

    # Sim time: 2ns * number of values (includes margin after last transition)
    sim_time = f'{step_counts[0] * 2}ns'

    return input_stimuli, sim_time

  def convert_cell_lib(
    self
  ):
    """Convert standard cell library to ngspice format with SKY130 models"""

    # Get cell spice lib from user-specified path
    input_file = Path(self.args.spice)
    if not input_file.is_absolute():
      input_file = Path.cwd() / input_file

    # Read input file
    content = input_file.read_text()

    # Convert transistor models to SKY130 names
    content = re.sub(r'\bPMOS\b', 'sky130_fd_pr__pfet_01v8', content)
    content = re.sub(r'\bNMOS\b', 'sky130_fd_pr__nfet_01v8', content)
    content = re.sub(r'\bM\$', 'XM$', content)
    content = re.sub(r'\bM_P', 'XM_P', content)
    content = re.sub(r'\bM_N', 'XM_N', content)

    # Output cell lib to build directory
    spice_stem = Path(self.args.spice).stem
    output_file = (self.results_dir / f'{spice_stem}-sky130.sp').resolve()
    output_file.write_text(content)

    self.tb_data['cell_lib_path'] = str(output_file)

  def gen_spice_tb(
    self
  ):
    """Generate ngspice testbench netlist for the specified cell."""

    # Load testbench template
    template_path = Path(__file__).parent.parent / 'share/tinyflow-ngspice/tinyflow-ngspice-tb-tmpl.sp'
    if not template_path.exists():
      print(f"Error: template not found: {template_path}", file=sys.stderr)
      sys.exit(1)

    template_content = template_path.read_text()
    template = jinja2.Template(template_content)

    # Render template with testbench data
    rendered = template.render(self.tb_data)

    # Output testbench spice to build directory
    output_file = self.output_dir / f'{self.tb_data["output_basename"]}-tb.sp'
    output_file.write_text(rendered)

    self.tb_data['tb_path'] = str(output_file)

  def run_simulation(
    self
  ):
    """Run ngspice simulation and process results."""

    # Invoke ngspice with the generated testbench
    result = subprocess.run(
      ['ngspice', '-b', self.tb_data['tb_path']],
      capture_output=True,
      text=True
    )

    output = result.stdout + result.stderr

    # Filter out specific measurement interval errors from stderr - these are
    # expected when transitions are not captured within the simulation time,
    # also filter out non-increasing PWL time points warnings since we want the
    # optimal step function inputs for our simulations
    filtered_stderr_lines = []
    for line in result.stderr.splitlines():
      if "Error: measure  t_pdr  trig(TRIG) : out of interval" in line:
        continue
      if "Error: measure  t_pdr  trig(TARG) : out of interval" in line:
        continue
      if "Error: measure  t_pdf  trig(TRIG) : out of interval" in line:
        continue
      if "Error: measure  t_pdf  trig(TARG) : out of interval" in line:
        continue
      if "non-increasing PWL time points" in line:
        continue
      filtered_stderr_lines.append(line)
    filtered_stderr = '\n'.join(filtered_stderr_lines)

    # Print errors and warnings if any remain after filtering
    if filtered_stderr.strip() != '':
      print("------------------------------------------------")
      print("Ngspice Errors/Warnings:\n")
      print(filtered_stderr)
      print("------------------------------------------------")

    # Split output by "Measuring delays for input pin X" sections
    sections = re.split(r'Measuring delays for input pin (\w+)', output)

    # Read CSV waveform data and print transitions
    csv_file = self.output_dir / f'{self.tb_data["output_basename"]}.csv'
    if csv_file.exists():
      self._print_transitions(csv_file)

    # sections[0] is before first match, then alternates: pin, content, pin, content...
    self._log("\nMeasured delays:")
    for i in range(1, len(sections), 2):
      pin = sections[i]
      content = sections[i + 1] if i + 1 < len(sections) else ''

      # Extract t_pdf value (before "targ")
      t_pdf_match = re.search(r't_pdf\s*=\s*([\d.e+-]+)\s*targ', content)
      t_pdr_match = re.search(r't_pdr\s*=\s*([\d.e+-]+)\s*targ', content)

      # Determine t_pdf result
      if t_pdf_match and float(t_pdf_match.group(1)) >= 0:
        t_pdf_str = f'{t_pdf_match.group(1)} s'
      else:
        t_pdf_str = 'not captured'

      # Determine t_pdr result
      if t_pdr_match and float(t_pdr_match.group(1)) >= 0:
        t_pdr_str = f'{t_pdr_match.group(1)} s'
      else:
        t_pdr_str = 'not captured'

      self._log(f"{pin}->Y:")
      self._log(f"  t_pdf = {t_pdf_str}")
      self._log(f"  t_pdr = {t_pdr_str}")
    self._log()

    # Write results to text file
    results_file = self.output_dir / f'{self.tb_data["output_basename"]}.txt'
    results_file.write_text('\n'.join(self.output_lines))

  def _print_transitions(
    self,
    csv_file
  ):
    """Read CSV waveform data and print signal transitions."""

    # Read the header row to get signal names
    with open(csv_file, 'r') as f:
      header_line = f.readline().strip()

    # Parse column names (space or tab separated)
    col_names = header_line.split()

    # Load all data (skip header row)
    data = np.loadtxt(csv_file, skiprows=1, ndmin=2)

    # Parse column pairs: (time, signal_data)
    # Columns are organized as: time1 data1 time2 data2 ...
    if data.size == 0:
      print("Warning: no waveform data found", file=sys.stderr)
      return
    num_cols = data.shape[1]
    num_signals = num_cols // 2

    # Extract signal names and data
    signals = {}
    for i in range(num_signals):
      time_col_idx = i * 2
      data_col_idx = i * 2 + 1

      time = data[:, time_col_idx]
      signal_data = data[:, data_col_idx]

      # Get signal name from header (data column name)
      if data_col_idx < len(col_names):
        signal_name = col_names[data_col_idx]
        # Clean up signal name (remove v() wrapper if present)
        signal_name = signal_name.replace('v(', '').replace(')', '')
        signal_name = signal_name.replace('V(', '').replace(')', '')
      else:
        signal_name = f'Signal{i+1}'

      signals[signal_name] = (time, signal_data)

    # Determine sample times (1ns after each 2ns step boundary to capture settled values)
    # Get number of steps from sim_time
    sim_time_ns = int(self.tb_data['sim_time'].replace('ns', ''))
    num_steps = sim_time_ns // 2
    sample_times = [(i * 2 + 1) * 1e-9 for i in range(num_steps)]  # 1ns, 3ns, 5ns, ...

    # Voltage threshold for logic level (half of 1.8V supply)
    threshold = 0.9

    # Sample each signal and build transition string
    self._log("\nSignal transitions:")
    for signal_name, (time, signal_data) in signals.items():
      values = []
      for sample_time in sample_times:
        # Find the closest time index
        idx = np.searchsorted(time, sample_time)
        if idx >= len(signal_data):
          idx = len(signal_data) - 1
        voltage = signal_data[idx]
        logic_val = '1' if voltage > threshold else '0'
        values.append(logic_val)

      transition_str = '-'.join(values)
      self._log(f"  {signal_name}: {transition_str}")

  def plot_waveforms(
    self
  ):
    """Plot and save waveforms from ngspice CSV output using stacked subplots."""

    csv_file = self.output_dir / f'{self.tb_data["output_basename"]}.csv'

    if not csv_file.exists():
      print(f"Error: waveform file not found: {csv_file}", file=sys.stderr)
      return

    # Read the header row to get signal names
    with open(csv_file, 'r') as f:
      header_line = f.readline().strip()

    # Parse column names (space or tab separated)
    col_names = header_line.split()

    # Load all data (skip header row)
    data = np.loadtxt(csv_file, skiprows=1)

    # Parse column pairs: (time, signal_data)
    # Columns are organized as: time1 data1 time2 data2 ...
    num_cols = data.shape[1]
    num_signals = num_cols // 2

    # Extract signal names and data
    signals = []
    signal_names = []

    for i in range(num_signals):
      time_col_idx = i * 2
      data_col_idx = i * 2 + 1

      time = data[:, time_col_idx]
      signal_data = data[:, data_col_idx]

      # Get signal name from header (data column name)
      if data_col_idx < len(col_names):
        signal_name = col_names[data_col_idx]
        # Clean up signal name (remove v() wrapper if present)
        signal_name = signal_name.replace('v(', '').replace(')', '')
        signal_name = signal_name.replace('V(', '').replace(')', '')
      else:
        signal_name = f'Signal {i+1}'

      signals.append((time, signal_data))
      signal_names.append(signal_name)

    # Create figure with stacked subplots
    fig, axes = plt.subplots(num_signals, 1, figsize=(10, 2*num_signals), sharex=True)

    # Handle single subplot case
    if num_signals == 1:
      axes = [axes]

    # Plot each signal
    for ax, (time, signal_data), name in zip(axes, signals, signal_names):
      ax.plot(time * 1e9, signal_data, linewidth=2, color='blue')  # Convert time to ns
      ax.set_ylabel(f'{name}\n(V)', fontsize=10)
      ax.grid(True, alpha=0.3)
      ax.set_ylim([-0.2, 2.0])

      # Add horizontal reference lines at 0V and 1.8V
      ax.axhline(y=0, color='gray', linestyle='--', linewidth=0.5, alpha=0.5)
      ax.axhline(y=1.8, color='gray', linestyle='--', linewidth=0.5, alpha=0.5)

    # Label the bottom plot x-axis
    axes[-1].set_xlabel('Time (ns)', fontsize=10)

    # Set title
    title = f'{self.args.cell} Waveforms'
    fig.suptitle(title, fontsize=14, fontweight='bold')

    # Adjust layout and save
    plt.tight_layout()
    output_file = self.output_dir / f'{self.tb_data["output_basename"]}.png'
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    plt.close(fig)

if __name__ == '__main__':
  tinyflow_ngspice = TinyFlowNgspice()
  tinyflow_ngspice.parse_args()
  tinyflow_ngspice.convert_cell_lib()
  tinyflow_ngspice.gen_spice_tb()
  tinyflow_ngspice.run_simulation()
  tinyflow_ngspice.plot_waveforms()
